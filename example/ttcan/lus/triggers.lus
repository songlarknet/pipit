

node Trigger_Cycle_Current_Active(
  reset_ck:           bool;
  cycle_time:         Ntu;
  cycle_index:        Cycle_Index;
) returns (
  trigger_new:        bool;
  trigger_enabled:    bool;
  trigger:            Trigger;
  trigger_expired:    bool;
  tx_count:           int;
)
var
  next_enabled:       bool;
  next_index:         Trigger_Index;
  next_trigger:       Trigger;
  trigger_index:      Trigger_Index;
  trigger_expiry:     Ntu;
let
  trigger_new = false -> trigger_index <> pre trigger_index;

  (next_enabled, next_index, next_trigger) = Trigger_Cycle_Next_Active(reset_ck, cycle_time, cycle_index);

  -- If the new trigger is enabled and has reached its time mark, then the new trigger has precedence. This case allows Watch_Triggers to pre-empt Tx_Ref_Triggers, as Tx_Ref_Triggers do not expire otherwise.
  -- Otherwise, if the old trigger expired on the previous tick, then we the new trigger can be started. The delay here ensures that triggers can be handled by the state machine after their expiry.
  (trigger_enabled, trigger_index, trigger) =
    (next_enabled, next_index, next_trigger) ->
    if (next_enabled and next_trigger.trigger_Time_Mark >= cycle_time) or pre trigger_expired
    then (next_enabled, next_index, next_trigger)
    else pre (trigger_enabled, trigger_index, trigger);

  (* We keep trying to send Tx_Ref_Triggers until they're pre-empted by the next trigger, so their expiry is very large.
     We keep trying to send Tx_Triggers for Tx_Enable_Window ntus.
     We don't need to keep trying Rx_Triggers or Watch_Triggers. *)
  trigger_expiry     =
    if trigger.trigger_Type = Tx_Ref_Trigger
    then trigger.trigger_Time_Mark + 65535
    else if trigger.trigger_Type = Tx_Trigger
    then trigger.trigger_Time_Mark + config_tx_enable_window
    else trigger.trigger_Time_Mark;

  trigger_expired    = trigger_expiry < cycle_time;

  (*^5.1 Tx_Count: each time a Tx_Trigger becomes active, Tx_Count is incremented. Tx_Count is not incremented beyond Expected_Tx_Trigger. *)
  (* CLARIFICATION: the definition of "active" is not entirely clear to me.
    Is it whenever a Tx_Trigger trigger array entry is encountered by the trigger loop, or is it only when the trigger is enabled for the current cycle index?
    I think it must be every time it's encountered by the loop, because otherwise we would underflow for a periodic trigger that doesn't transmit every cycle.
    *)
  tx_count =
    (if reset_ck then 0 else (0 -> pre tx_count)) +
    (if (false -> next_index <> pre next_index) and next_trigger.trigger_Type = Tx_Trigger then 1 else 0);
tel

node Trigger_Cycle_Next_Active(
  reset_ck:           bool;
  cycle_time:         Ntu;
  cycle_index:        Cycle_Index;
) returns (
  trigger_enabled:    bool;
  trigger_index:      Trigger_Index;
  trigger:            Trigger;
)
var
  pre_trigger_index:    Trigger_Index;
let
  pre_trigger_index    = 0 -> pre trigger_index;

  trigger_index        = 0 ->
    if reset_ck
    then 0
    else if pre (not trigger_enabled) or pre trigger.trigger_Time_Mark < cycle_time
    then clamp(0, TRIGGERS_COUNT - 1, pre_trigger_index + 1)
    else pre_trigger_index;

  trigger              = config_Triggers_Lookup(trigger_index);

  trigger_enabled      = Trigger_Check_Enabled(cycle_index, trigger.trigger_Cycle_Offset, trigger.trigger_Repeat_Factor);
tel

-- Hide modular arithmetic
function Trigger_Check_Enabled(
  cycle_index: Cycle_Index;
  Cycle_Offset: Cycle_Index;
  Repeat_Factor: Repeat_Factor;
) returns (
  enabled: bool;
)
(*@contract
  guarantee cycle_index = Cycle_Offset => enabled;
*)
let
  enabled = (cycle_index - Cycle_Offset) mod Repeat_Factor = 0;
tel